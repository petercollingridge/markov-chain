<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 300 300">

<style>
    .node circle {
        fill: #888;
        opacity: 0.75;
    }

    .node text {
        text-anchor: middle;
        alignment-baseline: middle;
    }

    #edges line {
        stroke: #0056b3;
        stroke-width: 2;
        stroke-opacity: 0.7;
    }
</style>

<g id="edges">
</g>

<g id="nodes">
</g>

<script><![CDATA[
var width = 300;
var height = 300;
var ns = 'http://www.w3.org/2000/svg';

var REPULSION = 2000;

var force = 1000;
var data = [
    ['1', '2', force],
    ['1', '4', force],
    ['-1', '5', force],
    ['-1', '3', force],
    ['2', '-6', force],
    ['3', '-6', force],
    ['-2', '-1', force],
    ['-3', '1', force],
    ['4', '6', force],
    ['5', '6', force],
    ['-4', '-1', force],
    ['-5', '1', force],
    ['6', '-2', force],
    ['6', '-3', force],
    ['-6', '-4', force],
    ['-6', '-5', force],
];

// Create node objects
var nodesMap = {};
var nodes = [];
var edges = [];
var nodeGroup = document.getElementById('nodes');
var edgeGroup = document.getElementById('edges');

function addNode(letter) {
    nodesMap[letter] = { name: letter, r: 1 };
    nodes.push(nodesMap[letter]);
    return nodesMap[letter];
}

for (var i = 0; i < data.length; i++) {
    var item = data[i];
    var letter1 = item[0];
    var letter2 = item[1];
    var strength = item[2];

    var node1 = nodesMap[letter1] || addNode(letter1);
    var node2 = nodesMap[letter2] || addNode(letter2);
    node2.r++;

    edges.push({
        node1: node1,
        node2: node2,
        strength: strength,
    });
}

// Add node elements

function transformNode(node) {
    node.element.setAttributeNS(null, 'transform', 'translate(' + node.x + " " + node.y + ')');
}

function updateEdgePosition(edge) {
    var x1 = edge.node1.x;
    var y1 = edge.node1.y;
    var x2 = edge.node2.x;
    var y2 = edge.node2.y;
    var dx = x2 - x1;
    var dy = y2 - y1;
    var d = Math.sqrt(dx * dx + dy * dy);
    var d1 = edge.node1.r / d;
    var d2 = edge.node2.r / d;

    edge.element.setAttributeNS(null, 'x1', x1 + d1 * dx);
    edge.element.setAttributeNS(null, 'y1', y1 + d1 * dy);
    edge.element.setAttributeNS(null, 'x2', x2 - d2 * dx);
    edge.element.setAttributeNS(null, 'y2', y2 - d2 * dy);
}

for (var i = 0; i < nodes.length; i++) {
    var node = nodes[i];
    node.x = Math.random() * 300;
    node.y = Math.random() * 300;
    node.dx = Math.random() - 0.5;
    node.dy = Math.random() - 0.5;

    var nodeElement = document.createElementNS(ns, 'g');
    nodeElement.setAttributeNS(null, 'class', 'node');
    node.element = nodeElement;
    transformNode(node);

    var circle = document.createElementNS(ns, 'circle');
    node.r = Math.sqrt(node.r) * 10;
    circle.setAttributeNS(null, 'r', node.r);

    var text = document.createElementNS(ns, 'text');
    var textNode = document.createTextNode(node.name);

    nodeGroup.appendChild(nodeElement);
    nodeElement.appendChild(circle);
    nodeElement.appendChild(text);
    text.appendChild(textNode);
}

// Create edges
for (var i = 0; i < edges.length; i++) {
    var edge = edges[i];
    edge.element = document.createElementNS(ns, 'line');
    updateEdgePosition(edge);
    edgeGroup.appendChild(edge.element);
}

var n = nodes.length;

// Animation

function update() {
    // Nodes repel based on distance
    for (var i = 0; i < n - 1; i++) {
        var node1 = nodes[i];
        var x1 = node1.x;
        var y1 = node1.y;

        for (var j = i + 1; j < n; j++) {
            var node2 = nodes[j];
            var x2 = node2.x;
            var y2 = node2.y;

            var dx = x2 - x1;
            var dy = y2 - y1;
            var d2 = dx * dx + dy * dy;
            d2 = REPULSION / (d2 * d2);
            dx *= d2;
            dy *= d2;

            node1.dx -= dx;
            node1.dy -= dy;
            node2.dx += dx;
            node2.dy += dy;
        }
    }

    // Attract along edges
    for (var i = 0; i < edges.length; i++) {
        var node1 = edges[i].node1;
        var node2 = edges[i].node2;
        var dx = node2.x - node1.x;
        var dy = node2.y - node1.y;
        var d = dx * dx + dy * dy;

        if (d > node1.r * node1.r + node2.r * node2.r + 1600) {
            d = Math.sqrt(d) * 7;
            dx /= d;
            dy /= d;

            node1.dx += dx;
            node1.dy += dy;
            node2.dx -= dx;
            node2.dy -= dy;
        }
    }

    // Move nodes
    for (var i = 0; i < n; i++) {
        var node = nodes[i];

        // Move
        node.x += node.dx;
        node.y += node.dy;

        // Bounce off edges
        if (node.x < node.r) {
            node.x = 2 * node.r - node.x;
            node.dx *= -1;
        } else if (node.x > width - node.r) {
            node.x = 2 * (width - node.r) - node.x;
            node.dx *= -1;
        }

        if (node.y < node.r) {
            node.y = 2 * node.r - node.y;
            node.dy *= -1;
        } else if (node.y > height - node.r) {
            node.y = 2 * (height - node.r) - node.y;
            node.dy *= -1;
        }
        
        // Friction
        node.dx *= (1 - node.r / (node.r + 180));
        node.dy *= (1 - node.r / (node.r + 180));

        transformNode(node);
    }

    // Update edges
    for (var i = 0; i < edges.length; i++) {
        updateEdgePosition(edges[i]);
    }

    // Loop
    setTimeout(update, 20);
} 

update();

]]></script>

</svg>